{"version":3,"sources":["../../../../../lib/idx/remediators/GenericRemediator/util.ts"],"names":["unwrapFormValue","remediation","res","key","value","Array","isArray","formKeys","length","unwrappedForm","forEach","hasValidInputValue","input","values","fn","requiredTracker","name","type","options","required","isRequired","acc","item","selectedOption","id","optionSchema","option","idSchema","AuthSdkError"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AACA;;AADA;AAIO,SAASA,eAAT,CAAyBC,WAAzB,EAA6C;AAClD,QAAMC,GAAG,GAAG,EAAZ;;AACA,OAAK,MAAM,CAACC,GAAD,EAAMC,KAAN,CAAX,IAA2B,sBAAeH,WAAf,CAA3B,EAAwD;AACtD,QAAIG,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,WAAvC,EAAoD;AAClD;AACD;;AAED,QAAIC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AACxBF,MAAAA,GAAG,CAACC,GAAD,CAAH,GAAW,kBAAAC,KAAK,MAAL,CAAAA,KAAK,EAAKJ,eAAL,CAAhB;AACD,KAFD,MAEO,IAAI,OAAOI,KAAP,KAAiB,QAArB,EAA+B;AAAA;;AACpC,YAAMG,QAAQ,GAAG,mBAAYH,KAAZ,CAAjB,CADoC,CAEpC;AACA;;AACA,UAAI,mCAAC,OAAD,EAAU,MAAV,kBAA2BD,GAA3B,KACCI,QAAQ,CAACC,MAAT,KAAoB,CADrB,IAEC,oCAAC,OAAD,EAAU,MAAV,mBAA2BD,QAAQ,CAAC,CAAD,CAAnC,CAFL,EAGE;AACA;AACA,cAAME,aAAa,GAAGT,eAAe,CAACI,KAAD,CAArC;AACA,8BAAeK,aAAf,EAA8BC,OAA9B,CAAsC,CAAC,CAACP,GAAD,EAAMC,KAAN,CAAD,KAAkB;AACtDF,UAAAA,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;AACD,SAFD;AAGD,OATD,MASO;AACL;AACAF,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWH,eAAe,CAACI,KAAD,CAA1B;AACD;AACF,KAjBM,MAiBA;AACL;AACAF,MAAAA,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;AACD;AACF;;AAED,SAAOF,GAAP;AACD,C,CAED;AACA;;;AACO,SAASS,kBAAT,CAA4BC,KAA5B,EAAmCC,MAAnC,EAA2C;AAChD,QAAMC,EAAE,GAAG,CAACF,KAAD,EAAQC,MAAR,EAAgBE,eAAhB,KAAoC;AAC7C,UAAM;AAAEC,MAAAA,IAAF;AAAQZ,MAAAA,KAAR;AAAea,MAAAA,IAAf;AAAqBC,MAAAA,OAArB;AAA8BC,MAAAA;AAA9B,QAA2CP,KAAjD;AACA,UAAMQ,UAAU,GAAGD,QAAQ,IAAIJ,eAA/B,CAF6C,CAI7C;;AACA,QAAIV,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AACxB,aAAO,qBAAAA,KAAK,MAAL,CAAAA,KAAK,EAAQ,CAACiB,GAAD,EAAMC,IAAN,KAAe;AACjC,eAAOD,GAAG,IAAIP,EAAE,CAACQ,IAAD,EAAOT,MAAM,CAACG,IAAD,CAAb,EAAqBI,UAArB,CAAhB,CADiC,CACiB;AACnD,OAFW,EAET,IAFS,CAAZ;AAGD,KAT4C,CAW7C;AACA;AACA;;;AACA,QAAIF,OAAJ,EAAa;AACX;AACA,UAAID,IAAI,KAAK,QAAb,EAAuB;AAAA;;AACrB,cAAMM,cAAc,GAAGV,MAAM,CAACG,IAAD,CAA7B;;AACA,YAAI,EAACO,cAAD,aAACA,cAAD,eAACA,cAAc,CAAEC,EAAjB,CAAJ,EAAyB;AACxB,iBAAO,KAAP;AACA;;AACD,cAAMC,YAAY,GAAG,mBAAAP,OAAO,MAAP,CAAAA,OAAO,EAAOQ,MAAD,IAAY;AAAA;;AAC5C,gBAAMC,QAAQ,GAAG,+BAAAD,MAAM,CAACtB,KAAP,kBAAkB,CAAC;AAAEY,YAAAA;AAAF,WAAD,KAAcA,IAAI,KAAK,IAAzC,CAAjB;AACA,iBAAOW,QAAQ,CAACvB,KAAT,KAAmBmB,cAAc,CAACC,EAAzC;AACD,SAH2B,CAA5B;;AAIA,YAAI,CAACC,YAAL,EAAmB;AACjB,iBAAO,KAAP;AACD;;AACD,eAAO,kEAAAA,YAAY,CAACrB,KAAb,kBACG,CAAC;AAAEe,UAAAA;AAAF,SAAD,KAAkB,CAAC,CAACA,QADvB,mBAEG,CAACE,GAAD,EAAM;AAAEL,UAAAA;AAAF,SAAN,KAAmB;AACzB,iBAAOK,GAAG,IAAI,CAAC,CAACE,cAAc,CAACP,IAAD,CAA9B;AACD,SAJI,EAIF,IAJE,CAAP;AAKD,OAnBU,CAqBX;;;AACA,UAAIG,QAAQ,KAAK,KAAjB,EAAwB;AACtB,eAAO,IAAP;AACD,OAxBU,CA0BX;;;AACA,UAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrB,eAAO,CAAC,CAACN,MAAM,CAACG,IAAD,CAAf;AACD,OA7BU,CA+BX;;;AACA,YAAM,IAAIY,oBAAJ,CAAkB,yBAAwB,wBAAehB,KAAf,CAAsB,EAAhE,CAAN;AACD,KA/C4C,CAiD7C;;;AACA,QAAI,CAACQ,UAAL,EAAiB;AACf,aAAO,IAAP;AACD;;AAED,WAAO,CAAC,EAAEP,MAAM,IAAIA,MAAM,CAACG,IAAD,CAAlB,CAAR;AACD,GAvDD;;AAyDA,SAAOF,EAAE,CAACF,KAAD,EAAQC,MAAR,EAAgB,KAAhB,CAAT;AACD","sourcesContent":["/* eslint-disable complexity */\nimport { AuthSdkError } from '../../../errors';\nimport { Input } from '../../types';\n\nexport function unwrapFormValue(remediation): Input { \n  const res = {};\n  for (const [key, value] of Object.entries(remediation)) {\n    if (value === null || typeof value === 'undefined') {\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      res[key] = value.map(unwrapFormValue);\n    } else if (typeof value === 'object') {\n      const formKeys = Object.keys(value as object);\n      // detect patterns like:\n      // value -> form -> value | form -> value\n      if (['value', 'form'].includes(key) \n        && formKeys.length === 1 \n        && ['value', 'form'].includes(formKeys[0])\n      ) {\n        // unwrap nested form\n        const unwrappedForm = unwrapFormValue(value);\n        Object.entries(unwrappedForm).forEach(([key, value]) => {\n          res[key] = value;\n        });\n      } else {\n        // dfs\n        res[key] = unwrapFormValue(value);\n      }\n    } else {\n      // handle primitive value\n      res[key] = value;\n    }\n  }\n\n  return res as Input;\n}\n\n// only check if value is required for now\n// TODO: support SDK layer type based input validation\nexport function hasValidInputValue(input, values) {\n  const fn = (input, values, requiredTracker) => {\n    const { name, value, type, options, required } = input;\n    const isRequired = required || requiredTracker;\n\n    // handle nested value - all required fields should be avaiable in values \n    if (Array.isArray(value)) {\n      return value.reduce((acc, item) => {\n        return acc && fn(item, values[name], isRequired); // recursive call\n      }, true);\n    }\n\n    // handle options field\n    // 1. object type options - check if each object field is required and value can be found from the selectedOption\n    // 2. primitive options - required field is avaiable from top level\n    if (options) {\n      // object type options\n      if (type === 'object') {\n        const selectedOption = values[name];\n        if (!selectedOption?.id) {\n         return false;\n        }\n        const optionSchema = options.find((option) => {\n          const idSchema = option.value.find(({ name }) => name === 'id' );\n          return idSchema.value === selectedOption.id;\n        });\n        if (!optionSchema) {\n          return false;\n        }\n        return optionSchema.value\n          .filter(({ required }) => !!required)\n          .reduce((acc, { name }) => {\n            return acc && !!selectedOption[name];\n          }, true);\n      }\n\n      // primitive options, not required - always valid\n      if (required === false) {\n        return true;\n      }\n\n      // primitive options, required - check if value is available\n      if (required === true) {\n        return !!values[name];\n      }\n\n      // unknown options, throw\n      throw new AuthSdkError(`Unknown options type, ${JSON.stringify(input)}`);\n    }\n\n    // base case\n    if (!isRequired) {\n      return true;\n    }\n      \n    return !!(values && values[name]);\n  };\n\n  return fn(input, values, false);\n}\n"],"file":"util.js"}